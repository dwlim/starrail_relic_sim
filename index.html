<!DOCTYPE html>
<html>
<body>

<div class="flex-container">
  <div id="relic_roller" class="flex-child">
    <h3>How to use relic roller:</h3>
    <p>Use the roll relics to do a Cavern run.
      <br>After you roll a relic you can level it up to see what substats it will have.
      <br>
    </p>
    <button onclick="rollRelics()">Roll Relics</button>
    <div id="relic_output"></div>
    <pre id="relic_results"></pre>
  </div>

  <div id="relic_simulator" class="flex-child">
    <h3>How to use relic simulator/TBP estimator:</h3>
    <p>Use the SIM Relics button to sim some relics. Each click should take about 1 second.
      <br>The more relics you SIM the more accurate it will be. 1 Million SIMs should be more than enough.
      <br>After you SIM some relics then you can enter a relic below and it will tell you how long before you can upgrade it
      <br>
    </p>
    <button onclick="simRelics()">SIM Relics</button>
    <div id="saved_relics"></div>
    <div id="relic_improve">
      <select id="piece-names" onchange="populateRelicMainStat(this.value)"><option>Choose a relic piece:</option></select>
      <select id="main-stat-names"><option>Choose a main stat:</option></select>
      <br>Atk%: <input type="number" id="relic-atk-perc">
      <br>Flat Atk: <input type="number" id="relic-atk">
      <br>Crit Rate: <input type="number" id="relic-cr">
      <br>Crit Damage: <input type="number" id="relic-cd">
      <br><button onclick="estimateTBPower()">Estimate TB Power</button>
      <br><div id="estimated-tb-power"></div>
    </div>
  </div>
</div>


<footer>
  <p><a href="https://docs.google.com/spreadsheets/d/1IuRGGDaaq14bqxMviVumx0P15E99VcCdwZ-hxIpNiuM/edit#gid=1361387223">Source</a> for stat distribution data</p>
</footer>
</body>
</html>


<script>
  const sim_trials = 100000;
  var relics = [];
  var relics_save = [];
  var trials_run = 0;

  const piece_options = ["Hat", "Glove", "Body", "Boots", "Orb", "Rope"];
  const main_stat_options = 
    [[["Hp"], [1]], 
    [["Atk"], [1]], 
    [["Hp%", "Atk%", "Def%", "CR", "CD", "Heal", "EHR"], [19.11, 20.03, 19.45, 10.84, 10.45, 9.72, 10.4]], 
    [["Hp%", "Atk%", "Def%", "Spd"], [27.84, 30.06, 29.95, 12.15]],
    [["Hp%", "Atk%", "Def%", "Phys DMG", "Fire DMG", "Ice DMG", "Lightning DMG", "Wind DMG", "Quant DMG", "Img DMG"], [11.79, 12.67, 11.68, 9.12, 9.12, 9.12, 9.12, 9.12, 9.12, 9.12]],
    [["Hp%", "Atk%", "Def%", "BE", "ERR%"], [27.29, 27.74, 23.60, 15.68, 5.68]]];
  const main_value = {
    "Hp": {"base": 112.896, "level": 39.5136}
  };

  const sub_stat_options = ["Hp", "Atk", "Def", "Hp%", "Atk%", "Def%", "Spd", "CR", "CD", "EHR", "ER", "BE"];
  const sub_stat_weights = 
  [
    [
      [0, 10.38, 10.83, 10.79, 11.17, 11.07, 4.68, 7.27, 6.93, 9.13, 8.71, 9.04]
    ],
    [
      [10.38, 0, 10.83, 10.79, 11.17, 11.07, 4.68, 7.27, 6.93, 9.13, 8.71, 9.04]
    ], 
    [
      [10.77, 10.74, 10.72, 0, 11.07, 11.07, 4.68, 7.27, 6.93, 9.13, 8.71, 9.04], 
      [10.77, 10.74, 10.72, 11.07, 0, 11.07, 4.68, 7.27, 6.93, 9.13, 8.71, 9.04], 
      [10.77, 10.74, 10.72, 11.07, 11.07, 0, 4.68, 7.27, 6.93, 9.13, 8.71, 9.04],
      [10.53, 10.53, 10.53, 10.53, 10.53, 10.53, 4.78, 0, 6.22, 8.61, 8.61, 8.61],
      [10.53, 10.53, 10.53, 10.53, 10.53, 10.53, 4.78, 6.22, 0, 8.61, 8.61, 8.61],
      [9.99, 9.81, 10.68, 9.77, 10.14, 10.03, 4.22, 6.38, 5.38, 8.06, 7.52, 8.02],
      [9.92, 11.57, 8.60, 12.07, 11.40, 10.58, 5.29, 6.61, 7.11, 0, 7.77, 9.09]
    ], 
    [
      [10.77, 10.74, 10.72, 0, 11.07, 11.07, 4.68, 7.27, 6.93, 9.13, 8.71, 9.04],
      [10.77, 10.74, 10.72, 11.07, 0, 11.07, 4.68, 7.27, 6.93, 9.13, 8.71, 9.04],
      [10.77, 10.74, 10.72, 11.07, 11.07, 0, 4.68, 7.27, 6.93, 9.13, 8.71, 9.04],
      [9.10, 9.88, 12.04, 9.26, 9.88, 8.95, 0, 5.71, 6.94, 9.26, 9.57, 9.41]
    ],
    [
      [10.77, 10.74, 10.72, 0, 11.07, 11.07, 4.68, 7.27, 6.93, 9.13, 8.71, 9.04],
      [10.77, 10.74, 10.72, 11.07, 0, 11.07, 4.68, 7.27, 6.93, 9.13, 8.71, 9.04],
      [10.77, 10.74, 10.72, 11.07, 11.07, 0, 4.68, 7.27, 6.93, 9.13, 8.71, 9.04],
      [9.99, 9.81, 10.68, 9.77, 10.14, 10.03, 4.22, 6.38, 5.38, 8.06, 7.52, 8.02],
      [9.99, 9.81, 10.68, 9.77, 10.14, 10.03, 4.22, 6.38, 5.38, 8.06, 7.52, 8.02],
      [9.99, 9.81, 10.68, 9.77, 10.14, 10.03, 4.22, 6.38, 5.38, 8.06, 7.52, 8.02],
      [9.99, 9.81, 10.68, 9.77, 10.14, 10.03, 4.22, 6.38, 5.38, 8.06, 7.52, 8.02],
      [9.99, 9.81, 10.68, 9.77, 10.14, 10.03, 4.22, 6.38, 5.38, 8.06, 7.52, 8.02],
      [9.99, 9.81, 10.68, 9.77, 10.14, 10.03, 4.22, 6.38, 5.38, 8.06, 7.52, 8.02],
      [9.99, 9.81, 10.68, 9.77, 10.14, 10.03, 4.22, 6.38, 5.38, 8.06, 7.52, 8.02]
    ],
    [
      [10.77, 10.74, 10.72, 0, 11.07, 11.07, 4.68, 7.27, 6.93, 9.13, 8.71, 9.04],
      [10.77, 10.74, 10.72, 11.07, 0, 11.07, 4.68, 7.27, 6.93, 9.13, 8.71, 9.04],
      [10.77, 10.74, 10.72, 11.07, 11.07, 0, 4.68, 7.27, 6.93, 9.13, 8.71, 9.04],
      [9.27, 11.21, 11.05, 9.11, 10.79, 10.29, 4.05, 7.17, 8.09, 9.78, 9.19, 0],
      [9.99, 9.81, 10.68, 9.77, 10.14, 10.03, 4.22, 6.38, 5.38, 8.06, 7.52, 8.02]
    ]
  ]

  const sub_stat_values = 
    [[33.87, 38.103755, 42.33751],
      [16.935, 19.051877, 21.168754],
      [16.935, 19.051877, 21.168754],
      [3.456, 3.888, 4.32],
      [3.456, 3.888, 4.32],
      [4.32, 4.86, 5.4],
      [2, 2.3, 2.6],
      [2.592, 2.916, 3.24],
      [5.184, 5.832, 6.48],
      [3.456, 3.888, 4.32],
      [3.456, 3.888, 4.32],
      [5.184, 5.832, 6.48]]

  for(var i = 0; i < piece_options.length; i++) {
    var opt = piece_options[i];
    var el = document.createElement("option");
    el.textContent = opt;
    el.value = opt;
    document.getElementById("piece-names").appendChild(el);
  }

  function populateRelicMainStat(chosen_piece){
    document.getElementById("main-stat-names").innerHTML = "";
    for(var i = 0; i < main_stat_options[piece_options.indexOf(chosen_piece)][0].length; i++) {
      var opt = main_stat_options[piece_options.indexOf(chosen_piece)][0][i];
      var el = document.createElement("option");
      el.textContent = opt;
      el.value = opt;
      document.getElementById("main-stat-names").appendChild(el);
    }
  }
  

  function buildUI() {
    document.getElementById("relic_output").innerHTML = "";
    for (const element of relics) {
      const tbl = document.createElement('table');
      const title_header = tbl.insertRow();
      title_header.innerHTML = "<b>" + element.name + " of Set " + element.set + "</b>"
      const level_tr = tbl.insertRow();
      const level_td1 = level_tr.insertCell();
      const level_td2 = level_tr.insertCell();
      level_td1.innerHTML = "Level:";
      level_td2.innerHTML = element.level;
      const main_tr = tbl.insertRow();
      const main_td1 = main_tr.insertCell();
      const main_td2 = main_tr.insertCell();
      main_td1.innerHTML = element.main_stat;

      for (const substat of Object.keys(element.sub_stats)) {
        if (element.sub_stats[substat].show == true) {
          const tr = tbl.insertRow();
          const td1 = tr.insertCell();
          const td2 = tr.insertCell();

          td1.innerHTML = substat;
          td2.innerHTML = element.sub_stats[substat].value;
        }
      }
      const btn = document.createElement('button');
      btn.textContent = "Level Relic";
      btn.onclick = function() {levelRelics(element);}
      document.getElementById("relic_output").appendChild(btn);
      document.getElementById("relic_output").appendChild(tbl);


    }
  }

  function refreshUI() {
    document.getElementById("relic_results").innerHTML = JSON.stringify(relics, undefined, 2);
  }

  function rollRelics() {
    relics.length = 0;
    generateRelic();
    buildUI();
  }

  function simRelics() {
    const start = Date.now();
    const res = [...Array(sim_trials)].map((_, i) => generateRelic(true));
    const end = Date.now();
    console.log(`done in ${end - start} ms`);
    trials_run += sim_trials;
    document.getElementById("saved_relics").innerHTML = "You have run " + trials_run + " trials and have " + relics_save.length + " relics saved.";
  }

  function levelRelics(element, sim) {
    if (element.level >= 15){
      return;
    }
    if (element.hidden) {
      element.sub_stats[element.hidden].show = true;
      element.hidden = null;
    } else {
      let sub_index = Object.keys(element.sub_stats)[Math.floor(Math.random() * 4)];
      let level_increment = sub_stat_values[element.sub_stats[sub_index].index][Math.floor(Math.random()*3)];
      element.sub_stats[sub_index].value += level_increment;
    }
    element.level += 3;
    if (!sim) {
      buildUI();
    }
  }

function weighted_random(r_items, r_weights) {
    var items = [...r_items];
    var weights = [...r_weights];
    var i;

    for (i = 1; i < weights.length; i++)
        weights[i] += weights[i - 1];
    
    var random = Math.random() * weights[weights.length - 1];
    
    for (i = 0; i < weights.length; i++)
        if (weights[i] > random)
            break;
    
    return items[i];
  }

  function accumulate(numbers) {
    let accm  = [];
    let total = 0;
    for (let n of numbers) {
        total += n;
        accm.push(total)
    }
    return accm;
  }

  function bisect_left(arr, target) {
    let n = arr.length;
    let l = 0;
    let r = n - 1;
    while (l <= r) {
        let m = Math.floor((l + r) / 2);
        if (arr[m] < target) {
            l = m + 1;
        } else if (arr[m] >= target) {
            r = m - 1;
        } 
    }
    return l;
  }

  function wchoice(population, weights, accumulated) {
    let acm = (accumulated) ? weights : accumulate(weights);
    let rnd = Math.random() * acm[acm.length - 1];

    let idx = bisect_left(acm, rnd);

    return [idx, population[idx]];
  }

  function wsample(population, weights, k) {
    let sample  = [];
    let indices = [];
    let index   = 0;
    let choice  = null;
    let acmwts  = accumulate(weights);

    for (let i=0; i < k; i++) {
        [index, choice] = wchoice(population, acmwts, true);
        sample.push(choice);
        indices.push(index);

        // The below updates the accumulated weights as if the member
        // at `index` has a weight of 0, eliminating it from future draws.
        // This portion could be optimized. See note below.
        let ndecr = weights[index];
        for (; index < acmwts.length; index++) {
            acmwts[index] -= ndecr;
        }
    }
    return [indices, sample];
  }

  function generateRelic(sim) {
    let num_pieces = Math.random() < 0.108 ? 3 : 2;

    for (let i = 0; i < num_pieces; i++) {
      var item = {};

      let piece = Math.floor(Math.random() * piece_options.length);
      item.name = piece_options[piece];
      item.main_stat = weighted_random(main_stat_options[piece][0], main_stat_options[piece][1]);
      item.sub_stats = [];
      item.level = 0;

      let main_index = main_stat_options[piece][0].indexOf(item.main_stat);
      let sub = wsample(sub_stat_options, sub_stat_weights[piece][main_index], 4);
      for (let i=0; i < sub[0].length; i++) {
        var subs = {};
        var stat = sub[1][i];
        subs.index = sub[0][i];
        subs.value = sub_stat_values[sub[0][i]][Math.floor(Math.random()*3)];
        if (i==3 && Math.random() < .8) {
          subs.show = false;
          item.hidden = stat;
        } else {
          subs.show = true;
        }
        item.sub_stats[stat] = subs;
      }
      item.set = Math.random() < .5 ? "1" : "2";

      if (!sim) {
        relics.push(item);
      } else {
        const res = [...Array(5)].map((_, i) => levelRelics(item, sim));
        relics_save.push(item);
      }
    }
  }

  function filterRelics(piece, mainstat) {
    return relics_save.filter(relic => (relic.name == piece) && (relic.main_stat === mainstat) && (relic.set === "1"));
  }

  function scoreRelics(relic_list, threshold) {
    effective_score = [];
    for (let i=0; i < relic_list.length; i++){
      let score = relic_list[i].sub_stats;
      effective_score.push(
        (score["Atk%"] ? score["Atk%"].value : 0) * .8 + 
        (score["Atk"] ? score["Atk"].value : 0) * .02 + 
        (score["CR"] ? score["CR"].value : 0) * 2 +
        (score["CD"] ? score["CD"].value : 0)
      );
    }
    return effective_score.filter(s => s > threshold);
  }

  function weightRelic(atk_perc, atk, cr, cd) {
    return (parseFloat(atk_perc) ? parseFloat(atk_perc) : 0) * .8 + 
      (parseFloat(atk) ? parseFloat(atk) : 0)  * .02 + 
      (parseFloat(cr) ? parseFloat(cr) : 0) * 2 + 
      (parseFloat(cd) ? parseFloat(cd) : 0);
  }

  function estimateTBPower() {
    var calculated_weight = weightRelic(document.getElementById("relic-atk-perc").value, document.getElementById("relic-atk").value, document.getElementById("relic-cr").value, document.getElementById("relic-cd").value);
    var scores = scoreRelics(filterRelics(document.getElementById("piece-names").value, document.getElementById("main-stat-names").value), calculated_weight);
    document.getElementById("estimated-tb-power").innerHTML = "Required TB Power: " + Math.floor(trials_run / scores.length * 40) + " or Days: " + Math.floor(trials_run / scores.length * 40 / 240);
  }

</script>

<style>
  .flex-container {
    display: flex;
  }

  .flex-child {
    flex: 1;
  }  

  .flex-child:first-child {
    margin-right: 20px;
  } 
</style>