<!DOCTYPE html>
<html>
<body>

<button onclick="rollRelics()">Roll Relics</button>
<button onclick="simRelics()">SIM Relics</button>


<div id="relic_output"></div>
<pre id="relic_results"></pre>
<div id="saved_relics"></div>
<div id="relic_improve">
  Sim some relics before you use this <br>
  <select id="piece-names" onchange="populateRelicMainStat(this.value)"><option>Choose a relic piece:</option></select>
  <select id="main-stat-names"><option>Choose a main stat:</option></select>
  <br>Atk%: <input type="number" id="relic-atk-perc">
  <br>Flat Atk: <input type="number" id="relic-atk">
  <br>Crit Rate: <input type="number" id="relic-cr">
  <br>Crit Damage: <input type="number" id="relic-cd">
  <br><button onclick="estimateTBPower()">Estimate TB Power</button>
  <br><div id="estimated-tb-power"></div>
</div>

</body>
</html>


<script>
  const sim_trials = 100000;
  var relics = [];
  var relics_save = [];
  var trials_run = 0;

  const piece_options = ["Hat", "Glove", "Body", "Boots"]; //, "Orb", "Rope"];
  const main_stat_options = 
    [[["Hp"], [1]], 
    [["Atk"], [1]], 
    [["Hp%", "Atk%", "Def%", "CR", "CD", "Heal", "EHR"], [20, 20, 20, 10, 10, 10, 10]], 
    [["Hp", "Atk", "Def", "Spd"], [27.5, 30, 30, 12.5]]];
  const main_value = {
    "Hp": {"base": 112.896, "level": 39.5136}
  };

  const sub_stat_options = ["Hp", "Atk", "Def", "Hp%", "Atk%", "Def%", "Spd", "CR", "CD", "EHR", "ER", "BE"];
  const sub_stat_weights = 
  [[[0, 11, 11, 11, 11, 11, 5, 6.5, 6.5, 9, 9, 9]],
    [[11, 0, 11, 11, 11, 11, 5, 6.5, 6.5, 9, 9, 9]], 
    [[11, 11, 11, 0, 11, 11, 5, 6.5, 6.5, 9, 9, 9], 
    [11, 11, 11, 11, 0, 11, 5, 6.5, 6.5, 9, 9, 9], 
    [11, 11, 11, 11, 11, 0, 5, 6.5, 6.5, 9, 9, 9],
    [10.53, 10.53, 10.53, 10.53, 10.53, 10.53, 4.78, 0, 6.22, 8.61, 8.61, 8.61],
    [10.53, 10.53, 10.53, 10.53, 10.53, 10.53, 4.78, 6.22, 0, 8.61, 8.61, 8.61],
    [9.91, 9.91, 9.91, 9.91, 9.91, 9.91, 4.5, 5.86, 5.86, 8.11, 8.11, 8.11],
    [10.78, 10.78, 10.78, 10.78, 10.78, 10.78, 4.9, 6.37, 6.37, 0, 8.82, 8.82]
    ], 
    [[11, 11, 11, 0, 11, 11, 5, 6.5, 6.5, 9, 9, 9],
    [11, 11, 11, 11, 0, 11, 5, 6.5, 6.5, 9, 9, 9],
    [11, 11, 11, 11, 11, 0, 5, 6.5, 6.5, 9, 9, 9],
    [10.38, 10.38, 10.38, 10.38, 10.38, 10.38, 0, 6.13, 6.13, 8.49, 8.49, 8.49]]]

  const sub_stat_values = 
    [[33.87, 38.103755, 42.33751],
      [16.935, 19.051877, 21.168754],
      [16.935, 19.051877, 21.168754],
      [3.456, 3.888, 4.32],
      [3.456, 3.888, 4.32],
      [4.32, 4.86, 5.4],
      [2, 2.3, 2.6],
      [2.592, 2.916, 3.24],
      [5.184, 5.832, 6.48],
      [3.456, 3.888, 4.32],
      [3.456, 3.888, 4.32],
      [5.184, 5.832, 6.48]]

  for(var i = 0; i < piece_options.length; i++) {
    var opt = piece_options[i];
    var el = document.createElement("option");
    el.textContent = opt;
    el.value = opt;
    document.getElementById("piece-names").appendChild(el);
  }

  function populateRelicMainStat(chosen_piece){
    document.getElementById("main-stat-names").innerHTML = "";
    for(var i = 0; i < main_stat_options[piece_options.indexOf(chosen_piece)][0].length; i++) {
      var opt = main_stat_options[piece_options.indexOf(chosen_piece)][0][i];
      var el = document.createElement("option");
      el.textContent = opt;
      el.value = opt;
      document.getElementById("main-stat-names").appendChild(el);
    }
  }
  

  function buildUI() {
    document.getElementById("relic_output").innerHTML = "";
    for (const element of relics) {
      const tbl = document.createElement('table');
      tbl.style = "background:#d8d8d8;";
      const title_header = tbl.insertRow();
      title_header.innerHTML = "<b>" + element.name + " of Set " + element.set + "</b>"
      const main_tr = tbl.insertRow();
      main_tr.style = "color: #d8872c; background: #cbcbcb;";
      const main_td1 = main_tr.insertCell();
      const main_td2 = main_tr.insertCell();
      main_td1.innerHTML = element.main_stat;

      for (const substat of Object.keys(element.sub_stats)) {
        if (element.sub_stats[substat].show == true) {
          const tr = tbl.insertRow();
          tr.style = "background: #d1d1d3;";
          const td1 = tr.insertCell();
          const td2 = tr.insertCell();

          td1.innerHTML = substat;
          td2.innerHTML = element.sub_stats[substat].value;
        }
      }
      const btn = document.createElement('button');
      btn.textContent = "Level Relic";
      btn.onclick = function() {levelRelics(element);}
      document.getElementById("relic_output").appendChild(btn);
      document.getElementById("relic_output").appendChild(tbl);


    }
  }

  function refreshUI() {
    document.getElementById("relic_results").innerHTML = JSON.stringify(relics, undefined, 2);
  }

  function rollRelics() {
    relics.length = 0;
    generateRelic();
    buildUI();
  }

  function simRelics() {
    const start = Date.now();
    const res = [...Array(sim_trials)].map((_, i) => generateRelic(true));
    const end = Date.now();
    console.log(`done in ${end - start} ms`);
    trials_run += sim_trials;
    document.getElementById("saved_relics").innerHTML = "You have run " + trials_run + " trials and have " + relics_save.length + " relics saved.";
  }

  function levelRelics(element, sim) {
    if (element.level >= 15){
      return;
    }
    let hiddenSub = Object.keys(element.sub_stats).filter(sub => element.sub_stats[sub].show === false);
    if (hiddenSub.length === 1) {
      element.sub_stats[hiddenSub].show = true;
    } else {
      let sub_index = Object.keys(element.sub_stats)[Math.floor(Math.random() * 4)];
      let level_increment = sub_stat_values[element.sub_stats[sub_index].index][Math.floor(Math.random()*3)];
      element.sub_stats[sub_index].value += level_increment;
    }
    element.level += 3;
    if (!sim) {
      buildUI();
    }
  }

function weighted_random(r_items, r_weights) {
    var items = [...r_items];
    var weights = [...r_weights];
    var i;

    for (i = 1; i < weights.length; i++)
        weights[i] += weights[i - 1];
    
    var random = Math.random() * weights[weights.length - 1];
    
    for (i = 0; i < weights.length; i++)
        if (weights[i] > random)
            break;
    
    return items[i];
  }

  function accumulate(numbers) {
    let accm  = [];
    let total = 0;
    for (let n of numbers) {
        total += n;
        accm.push(total)
    }
    return accm;
  }

  function bisect_left(arr, target) {
    let n = arr.length;
    let l = 0;
    let r = n - 1;
    while (l <= r) {
        let m = Math.floor((l + r) / 2);
        if (arr[m] < target) {
            l = m + 1;
        } else if (arr[m] >= target) {
            r = m - 1;
        } 
    }
    return l;
  }

  function wchoice(population, weights, accumulated) {
    let acm = (accumulated) ? weights : accumulate(weights);
    let rnd = Math.random() * acm[acm.length - 1];

    let idx = bisect_left(acm, rnd);

    return [idx, population[idx]];
  }

  function wsample(population, weights, k) {
    let sample  = [];
    let indices = [];
    let index   = 0;
    let choice  = null;
    let acmwts  = accumulate(weights);

    for (let i=0; i < k; i++) {
        [index, choice] = wchoice(population, acmwts, true);
        sample.push(choice);
        indices.push(index);

        // The below updates the accumulated weights as if the member
        // at `index` has a weight of 0, eliminating it from future draws.
        // This portion could be optimized. See note below.
        let ndecr = weights[index];
        for (; index < acmwts.length; index++) {
            acmwts[index] -= ndecr;
        }
    }
    return [indices, sample];
  }

  function generateRelic(sim) {
    let num_pieces = Math.random() < 0.108 ? 3 : 2;

    for (let i = 0; i < num_pieces; i++) {
      var item = {};

      let piece = Math.floor(Math.random() * piece_options.length);
      item.name = piece_options[piece];
      item.main_stat = weighted_random(main_stat_options[piece][0], main_stat_options[piece][1]);
      // console.log(main_stat_options[piece][0]);
      // console.log(main_stat_options[piece][1]);
      item.sub_stats = [];
      item.level = 0;

      let main_index = main_stat_options[piece][0].indexOf(item.main_stat);
      let sub = wsample(sub_stat_options, sub_stat_weights[piece][main_index], 4);
      for (let i=0; i < sub[0].length; i++) {
        var subs = {};
        var stat = sub[1][i];
        subs.index = sub[0][i];
        subs.value = sub_stat_values[sub[0][i]][Math.floor(Math.random()*3)];
        subs.show = i==3 && Math.random() < .8 ? false : true;
        item.sub_stats[stat] = subs;
      }
      item.set = Math.random() < .5 ? "1" : "2";

      if (!sim) {
        relics.push(item);
      }
      if (sim) {
        const res = [...Array(5)].map((_, i) => levelRelics(item, sim));
      }
      relics_save.push(item);
    }
  }

  function filterRelics(piece, mainstat) {
    return relics_save.filter(relic => (relic.name == piece) && (relic.main_stat === mainstat) && (relic.set === "1"));
  }

  function scoreRelics(relic_list, threshold) {
    effective_score = [];
    for (let i=0; i < relic_list.length; i++){
      let score = relic_list[i].sub_stats;
      effective_score.push(
        (score["Atk%"] ? score["Atk%"].value : 0) * .8 + 
        (score["Atk"] ? score["Atk"].value : 0) * .02 + 
        (score["CR"] ? score["CR"].value : 0) * 2 +
        (score["CD"] ? score["CD"].value : 0)
      );
    }
    return effective_score.filter(s => s > threshold);
  }

  function weightRelic(atk_perc, atk, cr, cd) {
    return atk_perc * .8 + atk * .02 + cr * 2 + cd;
  }

  function estimateTBPower() {
    var calculated_weight = weightRelic(document.getElementById("relic-atk-perc").value, document.getElementById("relic-atk").value, document.getElementById("relic-cr").value, document.getElementById("relic-cd").value);
    var scores = scoreRelics(filterRelics(document.getElementById("piece-names").value, document.getElementById("main-stat-names").value), calculated_weight);
    document.getElementById("estimated-tb-power").innerHTML = sim_trials / scores.length * 40;
  }

  </script>