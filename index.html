<!DOCTYPE html>
<html>
<body>

<div class="flex-container">
  <div id="relic_roller" class="flex-child">
    <h3>How to use relic roller:</h3>
    <p>Use the roll relics to do a Cavern run.
      <br>After you roll a relic you can level it up to see what substats it will have.
      <br>
    </p>
    <button onclick="rollRelics('relic')">Roll Relics</button>
    <button onclick="rollRelics('planar')">Roll Planars</button>
    <div id="relic_output"></div>
    <pre id="relic_results"></pre>
  </div>

  <div id="relic_simulator" class="flex-child">
    <h3>How to use relic simulator/TBP estimator:</h3>
    <p>Use the SIM Relics button to sim some relics. Each click should take about 1 second.
      <br>The more relics you SIM the more accurate it will be. 1 Million SIMs should be more than enough.
      <br>After you SIM some relics then you can enter a relic below and it will tell you how long before you can upgrade it
      <br>
    </p>
    <button onclick="simRelics()">SIM Relics</button>
    <div id="saved_relics"></div>
    <div id="relic_improve">
      <select id="piece-names" onchange="populateRelicMainStat(this.value)"><option>Choose a relic piece:</option></select>
      <select id="main-stat-names"><option>Choose a main stat:</option></select>
      <div id="atk-scaling-formula">
        <p>You only need to fill in the sub stats you care about. For CRIT DPS that is Atk%, Atk, CR, CD</p>
        Flat HP: <input type="number" id="relic-hp-flat" value="0">
        <br>Flat Atk: <input type="number" id="relic-atk-flat" value="0" style="background-color: #fffdca;">
        <br>Flat Def: <input type="number" id="relic-def-flat" value="0">
        <br>HP%: <input type="number" id="relic-hp-perc" value="0">
        <br>Atk%: <input type="number" id="relic-atk-perc" value="0" style="background-color: #fffdca;">
        <br>Def%: <input type="number" id="relic-def-perc" value="0">
        <br>Speed: <input type="number" id="relic-spd" value="0">
        <br>Crit Rate: <input type="number" id="relic-cr" value="0" style="background-color: #fffdca;">
        <br>Crit Damage: <input type="number" id="relic-cd" value="0" style="background-color: #fffdca;">
        <br>Effect Hit Rate: <input type="number" id="relic-ehr" value="0">
        <br>Effect Res: <input type="number" id="relic-er" value="0">
        <br>Break Effect: <input type="number" id="relic-be" value="0">
        <br><button onclick="estimateTBPower()">Estimate TB Power for CRIT DPS</button>
      </div>

      <br><button onclick="showAdvanceMode()">Advanced Mode</button>
      <div id="advanced-mode" style="display:none;">
        <p>Add a weighting for each stat. Remember this is final stat value and not number of rolls</p>
        Flat HP: <input type="number" id="relic-hp-flat-weight" value="0">
        <br>Flat Atk: <input type="number" id="relic-atk-flat-weight" value="0.07">
        <br>Flat Def: <input type="number" id="relic-def-flat-weight" value="0">
        <br>HP%: <input type="number" id="relic-hp-perc-weight" value="0">
        <br>Atk%: <input type="number" id="relic-atk-perc-weight" value="0.9">
        <br>Def%: <input type="number" id="relic-def-perc-weight" value="0">
        <br>Speed: <input type="number" id="relic-spd-weight" value="0">
        <br>Crit Rate: <input type="number" id="relic-cr-weight" value="2">
        <br>Crit Damage: <input type="number" id="relic-cd-weight" value="1">
        <br>Effect Hit Rate: <input type="number" id="relic-ehr-weight" value="0">
        <br>Effect Res: <input type="number" id="relic-er-weight" value="0">
        <br>Break Effect: <input type="number" id="relic-be-weight" value="0">
      </div>
      <br><br>
      <div id="estimated-tb-power"></div>
      <div id="estimated-craft"></div>
      <div id="estimated-resin-craft"></div>
    </div>
  </div>
</div>


<footer>
  <p><a href="https://docs.google.com/spreadsheets/d/1IuRGGDaaq14bqxMviVumx0P15E99VcCdwZ-hxIpNiuM/edit#gid=1361387223">Source</a> for stat distribution data</p>
</footer>
</body>
</html>


<script>
  const sim_trials = 100000;
  var relics = [];
  var relics_save = [];
  var planars_save = [];
  var trials_run = 0;

  const piece_options = ["Hat", "Glove", "Body", "Boots", "Orb", "Rope"];
  const main_stat_options = 
    [
      [
        ["Hp"], 
        [1]
      ], 
      [
        ["Atk"], 
        [1]
      ], 
      [
        ["Hp%", "Atk%", "Def%", "CR", "CD", "Heal", "EHR"], 
        [19.72, 20.19, 19.13, 10.01, 10.47, 9.99, 10.51]
      ], 
      [
        ["Hp%", "Atk%", "Def%", "Spd"], 
        [27.90, 30.02, 29.51, 12.57]
      ],
      [
        ["Hp%", "Atk%", "Def%", "Phys DMG", "Fire DMG", "Ice DMG", "Lightning DMG", "Wind DMG", "Quant DMG", "Img DMG"], 
        [12.73, 12.31, 11.74, 9.03, 9.03, 9.03, 9.03, 9.03, 9.03, 9.03]
      ],
      [
        ["Hp%", "Atk%", "Def%", "BE", "ERR%"], 
        [26.74, 27.87, 24.62, 15.06, 5.72]
      ]
    ];

  const main_value = {
    "Hp": {"base": 112.896, "level": 39.5136}
  };

  const sub_stat_options = ["Hp", "Atk", "Def", "Hp%", "Atk%", "Def%", "Spd", "CR", "CD", "EHR", "ER", "BE"];
  const sub_stat_weights = 
    [
      [
        [0, 996, 1000, 976, 991, 984, 436, 644, 634, 819, 810, 820]
      ],
      [
        [974, 0, 1000, 976, 991, 984, 436, 644, 634, 819, 810, 820]
      ], 
      [
        [974, 996, 1000, 0, 991, 984, 436, 644, 634, 819, 810, 820],
        [974, 996, 1000, 976, 0, 984, 436, 644, 634, 819, 810, 820],
        [974, 996, 1000, 976, 991, 0, 436, 644, 634, 819, 810, 820],
        [974, 996, 1000, 976, 991, 984, 436, 0, 634, 819, 810, 820],
        [974, 996, 1000, 976, 991, 984, 436, 644, 0, 819, 810, 820],
        [974, 996, 1000, 976, 991, 984, 436, 644, 634, 819, 810, 820],
        [974, 996, 1000, 976, 991, 984, 436, 644, 634, 0, 810, 820]
      ], 
      [
        [974, 996, 1000, 0, 991, 984, 436, 644, 634, 819, 810, 820],
        [974, 996, 1000, 976, 0, 984, 436, 644, 634, 819, 810, 820],
        [974, 996, 1000, 976, 991, 0, 436, 644, 634, 819, 810, 820],
        [974, 996, 1000, 976, 991, 984, 0, 644, 634, 819, 810, 820]
      ],
      [
        [974, 996, 1000, 0, 991, 984, 436, 644, 634, 819, 810, 820],
        [974, 996, 1000, 976, 0, 984, 436, 644, 634, 819, 810, 820],
        [974, 996, 1000, 976, 991, 0, 436, 644, 634, 819, 810, 820],
        [974, 996, 1000, 976, 991, 984, 436, 644, 634, 819, 810, 820],
        [974, 996, 1000, 976, 991, 984, 436, 644, 634, 819, 810, 820],
        [974, 996, 1000, 976, 991, 984, 436, 644, 634, 819, 810, 820],
        [974, 996, 1000, 976, 991, 984, 436, 644, 634, 819, 810, 820],
        [974, 996, 1000, 976, 991, 984, 436, 644, 634, 819, 810, 820],
        [974, 996, 1000, 976, 991, 984, 436, 644, 634, 819, 810, 820],
        [974, 996, 1000, 976, 991, 984, 436, 644, 634, 819, 810, 820]
      ],
      [
        [974, 996, 1000, 0, 991, 984, 436, 644, 634, 819, 810, 820],
        [974, 996, 1000, 976, 0, 984, 436, 644, 634, 819, 810, 820],
        [974, 996, 1000, 976, 991, 0, 436, 644, 634, 819, 810, 820],
        [974, 996, 1000, 976, 991, 984, 436, 644, 634, 819, 810, 0],
        [974, 996, 1000, 976, 991, 984, 436, 644, 634, 819, 810, 820]
      ]
    ];
    
  const base_sub_stat_weight = [100, 100, 100, 100, 100, 100, 40, 50, 50, 80, 80, 80];

  const sub_stat_values = 
    [
      [33.87, 38.103755, 42.33751],
      [16.935, 19.051877, 21.168754],
      [16.935, 19.051877, 21.168754],
      [3.456, 3.888, 4.32],
      [3.456, 3.888, 4.32],
      [4.32, 4.86, 5.4],
      [2, 2.3, 2.6],
      [2.592, 2.916, 3.24],
      [5.184, 5.832, 6.48],
      [3.456, 3.888, 4.32],
      [3.456, 3.888, 4.32],
      [5.184, 5.832, 6.48]
    ];

  for(var i = 0; i < piece_options.length; i++) {
    var opt = piece_options[i];
    var el = document.createElement("option");
    el.textContent = opt;
    el.value = opt;
    document.getElementById("piece-names").appendChild(el);
  }

  function populateRelicMainStat(chosen_piece){
    document.getElementById("main-stat-names").innerHTML = "";
    for(var i = 0; i < main_stat_options[piece_options.indexOf(chosen_piece)][0].length; i++) {
      var opt = main_stat_options[piece_options.indexOf(chosen_piece)][0][i];
      var el = document.createElement("option");
      el.textContent = opt;
      el.value = opt;
      document.getElementById("main-stat-names").appendChild(el);
    }
  }
  
  function showAdvanceMode(){
    if(document.getElementById("advanced-mode").style.display === 'none'){
      document.getElementById("advanced-mode").style.display = 'block';
    } else {
      document.getElementById("advanced-mode").style.display = 'none';
    }
  }
  
  function buildUI() {
    document.getElementById("relic_output").innerHTML = "";
    for (const element of relics) {
      const tbl = document.createElement('table');
      const title_header = tbl.insertRow();
      title_header.innerHTML = "<b>" + element.name + " of Set " + element.set + "</b>"
      const level_tr = tbl.insertRow();
      const level_td1 = level_tr.insertCell();
      const level_td2 = level_tr.insertCell();
      level_td1.innerHTML = "Level:";
      level_td2.innerHTML = element.level;
      const main_tr = tbl.insertRow();
      const main_td1 = main_tr.insertCell();
      const main_td2 = main_tr.insertCell();
      main_td1.innerHTML = element.main_stat;

      for (const substat of Object.keys(element.sub_stats)) {
        if (element.hidden != substat) {
          const tr = tbl.insertRow();
          const td1 = tr.insertCell();
          const td2 = tr.insertCell();

          td1.innerHTML = substat;
          td2.innerHTML = element.sub_stats[substat].value;
        }
      }
      const btn = document.createElement('button');
      btn.textContent = "Level Relic";
      btn.onclick = function() {levelRelics(element);}
      document.getElementById("relic_output").appendChild(btn);
      document.getElementById("relic_output").appendChild(tbl);
    }
  }

  function refreshUI() {
    document.getElementById("relic_results").innerHTML = JSON.stringify(relics, undefined, 2);
  }

  function rollRelics(equip_type) {
    relics.length = 0;
    generateRelic(false, equip_type);
    buildUI();
  }

  function simRelics() {
    const start = Date.now();
    const gen_relic = [...Array(sim_trials)].map((_, i) => generateRelic(true, "relic"));
    const gen_planar = [...Array(sim_trials)].map((_, i) => generateRelic(true, "planar"));
    const end = Date.now();
    console.log(`done in ${end - start} ms`);
    trials_run += sim_trials;
    document.getElementById("saved_relics").innerHTML = "You have run " + trials_run + " trials and have " + relics_save.length + " relics saved and " + planars_save.length + " planars saved.";
  }

  function levelRelics(element, sim) {
    if (element.level >= 15){
      return;
    }
    if (element.hidden) {
      element.hidden = null;
    } else {
      let sub_index = Object.keys(element.sub_stats)[Math.floor(Math.random() * 4)];
      let level_increment = sub_stat_values[element.sub_stats[sub_index].index][Math.floor(Math.random()*3)];
      element.sub_stats[sub_index].value += level_increment;
    }
    element.level += 3;
    if (!sim) {
      buildUI();
    }
  }

  function accumulate(numbers) {
    let accm  = [];
    let total = 0;
    for (let n of numbers) {
        total += n;
        accm.push(total)
    }
    return accm;
  }

  function bisect_left(arr, target) {
    let n = arr.length;
    let l = 0;
    let r = n - 1;
    while (l <= r) {
        let m = Math.floor((l + r) / 2);
        if (arr[m] < target) {
            l = m + 1;
        } else if (arr[m] >= target) {
            r = m - 1;
        } 
    }
    return l;
  }

  function wchoice(population, weights, accumulated) {
    let acm = (accumulated) ? weights : accumulate(weights);
    let rnd = Math.random() * acm[acm.length - 1];

    let idx = bisect_left(acm, rnd);

    return [idx, population[idx]];
  }

  function wsample(population, weights, k) {
    let sample  = [];
    let indices = [];
    let index   = 0;
    let choice  = null;
    let acmwts  = accumulate(weights);

    for (let i=0; i < k; i++) {
        [index, choice] = wchoice(population, acmwts, true);
        sample.push(choice);
        indices.push(index);

        // The below updates the accumulated weights as if the member
        // at `index` has a weight of 0, eliminating it from future draws.
        // This portion could be optimized. See note below.
        let ndecr = weights[index];
        for (; index < acmwts.length; index++) {
            acmwts[index] -= ndecr;
        }
    }
    return [indices, sample];
  }

  function getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function generateRelic(sim, equip_type) {
    let num_pieces = Math.random() < 0.108 ? 3 : 2;
    let selected_piece_options = [];
    
    if (equip_type === "planar") {
      selected_piece_options = piece_options.slice(4, 6);
    } else {
      selected_piece_options = piece_options.slice(0, 4);
    }

    for (let i = 0; i < num_pieces; i++) {
      var item = {};

      let piece = equip_type === "planar" ? getRandomInt(4, 5) : getRandomInt(0, 3);
      item.name = piece_options[piece];
      item.main_stat = wsample(main_stat_options[piece][0], main_stat_options[piece][1], 1)[1][0];
      item.sub_stats = [];
      item.level = 0;

      let main_index = main_stat_options[piece][0].indexOf(item.main_stat);
      let sub = [];
      if (Math.random() < .8){
        first_three_sub = wsample(sub_stat_options, sub_stat_weights[piece][main_index], 3);
        fourth_weight = [...base_sub_stat_weight];
        exclude_index = [sub_stat_options.indexOf(item.main_stat)].concat(first_three_sub[0]);
        for (const index of exclude_index) {
          if (index >= 0){
            fourth_weight[index] = 0;
          }
        }
        fourth_sub = wsample(sub_stat_options, fourth_weight, 1);
        sub = [first_three_sub[0].concat(fourth_sub[0]), first_three_sub[1].concat(fourth_sub[1])]
        if (!sim) {
          item.hidden = sub[1][3];
        } else {
          item.level = 3;
        }
      } else {
        sub = wsample(sub_stat_options, sub_stat_weights[piece][main_index], 4);
      }
      
      for (let i=0; i < sub[0].length; i++) {
        var subs = {};
        var stat = sub[1][i];
        subs.index = sub[0][i];
        subs.value = sub_stat_values[sub[0][i]][Math.floor(Math.random()*3)];
        item.sub_stats[stat] = subs;
      }
      item.set = Math.random() < .5 ? "1" : "2";

      if (!sim) {
        relics.push(item);
      } else {
        const res = [...Array(5)].map((_, i) => levelRelics(item, sim));
        if (equip_type === "planar") {
          planars_save.push(item);
        } else {
          relics_save.push(item);
        }
      }
    }
  }

  function filterRelics(piece, mainstat) {
    let piece_save = piece_options.indexOf(piece) > 3 ? planars_save : relics_save;
    if (piece && mainstat) {
      return piece_save.filter(relic => (relic.name == piece) && (relic.main_stat === mainstat) && (relic.set === "1"));
    } if (piece) {
      return piece_save.filter(relic => (relic.name == piece) && (relic.set === "1"));
    }
  }

  function scoreRelics(relic_list, threshold) {
    effective_score = [];
    for (let i=0; i < relic_list.length; i++){
      let score = relic_list[i].sub_stats;
      let i_relic = [];
      i_relic.push([score["Hp"] ? score["Hp"].value : 0]);
      i_relic.push([score["Atk"] ? score["Atk"].value : 0]);
      i_relic.push([score["Def"] ? score["Def"].value : 0]);
      i_relic.push([score["Hp%"] ? score["Hp%"].value : 0]);
      i_relic.push([score["Atk%"] ? score["Atk%"].value : 0]);
      i_relic.push([score["Def%"] ? score["Def%"].value : 0]);
      i_relic.push([score["Spd"] ? score["Spd"].value : 0]);
      i_relic.push([score["CR"] ? score["CR"].value : 0]);
      i_relic.push([score["CD"] ? score["CD"].value : 0]);
      i_relic.push([score["EHR"] ? score["EHR"].value : 0]);
      i_relic.push([score["ER"] ? score["ER"].value : 0]);
      i_relic.push([score["BE"] ? score["BE"].value : 0]);
      effective_score.push(weightRelic(i_relic));
    }
    return effective_score.filter(s => s >= threshold);
  }

  function weightRelic(relic) {
    let weight =
      relic[0] * document.getElementById("relic-hp-flat-weight").value +
      relic[1] * document.getElementById("relic-atk-flat-weight").value +
      relic[2] * document.getElementById("relic-def-flat-weight").value +
      relic[3] * document.getElementById("relic-hp-perc-weight").value +
      relic[4] * document.getElementById("relic-atk-perc-weight").value +
      relic[5] * document.getElementById("relic-def-perc-weight").value +
      relic[6] * document.getElementById("relic-spd-weight").value +
      relic[7] * document.getElementById("relic-cr-weight").value +
      relic[8] * document.getElementById("relic-cd-weight").value +
      relic[9] * document.getElementById("relic-ehr-weight").value +
      relic[10] * document.getElementById("relic-er-weight").value +
      relic[11] * document.getElementById("relic-be-weight").value;
    return weight;
  }

  function estimateTBPower() {
    var relic = [];
    relic.push(document.getElementById("relic-hp-flat").value);
    relic.push(document.getElementById("relic-atk-flat").value);
    relic.push(document.getElementById("relic-def-flat").value);
    relic.push(document.getElementById("relic-hp-perc").value);
    relic.push(document.getElementById("relic-atk-perc").value);
    relic.push(document.getElementById("relic-def-perc").value);
    relic.push(document.getElementById("relic-spd").value);
    relic.push(document.getElementById("relic-cr").value);
    relic.push(document.getElementById("relic-cd").value);
    relic.push(document.getElementById("relic-ehr").value);
    relic.push(document.getElementById("relic-er").value);
    relic.push(document.getElementById("relic-be").value);
    var calculated_weight = weightRelic(relic);
    var scores = scoreRelics(filterRelics(document.getElementById("piece-names").value, document.getElementById("main-stat-names").value), calculated_weight);
    document.getElementById("estimated-tb-power").innerHTML = "Average TB Power: " + Math.ceil(trials_run / scores.length * 40) + " or Days: " + Math.ceil(trials_run / scores.length * 40 / 240);
    document.getElementById("estimated-craft").innerHTML = "Average Crafts Required: " + Math.ceil(filterRelics(document.getElementById("piece-names").value).length / scores.length);
    document.getElementById("estimated-resin-craft").innerHTML = "Average Self Modeling Resin Crafts required: " + Math.ceil(filterRelics(document.getElementById("piece-names").value, document.getElementById("main-stat-names").value).length / scores.length);
  }

</script>

<style>
  .flex-container {
    display: flex;
  }

  .flex-child {
    flex: 1;
  }  

  .flex-child:first-child {
    margin-right: 20px;
  } 
</style>